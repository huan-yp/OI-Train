##  CF432C

### 废话：

1. 这是一道好题。
2. 这道题我自闭了一下午，最后看 $\text{Tourist}$ 代码才写过。
3. 所以要来水一篇~~清楚~~的题解。

### 题意：

给定 $n$ 个字符串，长度为 $m$ ，随机选一个出来，每次随机获取一个还没有被获取的位置（得知这个位置上的字符），问期望多少次可以获取到这个字符串。所有随机均是等概率随机。

$m\leq 20,n\leq 50$

### 思路：

首先看到期望，考虑从后向前推。~~至于为什么我只能说题做多了就知道了。~~

然后看到 $m\leq 20$ ，并且注意到题目中只关心哪些位置还没有被获取，所以状压。

$dp[mask]$ 表示现在获取的状态为 $mask$ ，获取到这个字符串期望**还需要多少步**。显然有边界 $dp[(1<<m)-1]=0$ 。每次考虑填好 $dp[mask]$ ，那么枚举 $mask$ 上哪些位置还是 $0$ ，需要在这些位置中随机选一个来转移。

期望 $dp$ ，不，所有 $dp$ 的一个重要步骤都是考虑到下一步需要的代价。这道题的这个代价有那么~~一点点~~特殊。我们发现，其实获取到了某个状态 $mask$ ，其实有一部分字符串已经被我们确定出来了，不需要继续填了，然而，我们并不知道我们选到的字符串是不是已经被确定了，所以考虑枚举选到的字符串，看看它是否在 $mask$ 状态下能被确定好就可以了。

转移方程  :
$$
dp[mask]=\min_{i \in mask}(p[mask]+dp[mask|(1<<i)])
$$


$p[mask]$ 表示选到枚举的这个字符串的情况下，它在 $mask$ 能否被确定，能则 $p[mask]=0$

所以我们得到了一个 $O(2^n * n * m)$ 的做法。~~得到了 TLE 13 的好成绩~~。

认真观察这个柿子，再联想一下枚举选的字符串的过程，我们发现转移的时候关心的只是目前状态 $mask$ 下有多少个字符串还没确定。

那么就不枚举选择的字符串了，直接转移。

假设我们在 $mask$ 这里能还不能确定出来的字符串的个数为 $num_i$ ，那么我们转移的代价就是 $\dfrac{num_i}{n}$ ，为什么是这个？因为只有 $\dfrac{num_i}{n}$ 的可能会继续选下去。

所以剩下的问题就变成了统计 $mask$ 状态下哪些还不能确定。

我们发现其实 $m$ 也不大，所以枚举每一对字符串，看它们相同位置的集合。（一个字符串如果不能被确定，那么至少有一个字符串在这个状态下和它相同），状压这个集合即可。

具体实现见代码和其它大神的题解。

### 参考代码：

```cpp
#include<bits/stdc++.h>
#define y1 y3647
#define next nxt
#define earse erase
#define INF 1000000000
#define LL long long
#define low(x) (x)&(-x)
using namespace std;
inline void read(int &x)
{
	x=0;int f=1;
	char ch=getchar();
	while(ch!=45&&(ch>'9'||ch<'0'))ch=getchar();
	if(ch==45){f=-1,ch=getchar();}
	while(ch<='9'&&ch>='0'){x=x*10+ch-48;ch=getchar();}
	x*=f;
}
const int N=20,M=55;
int i,j,k,n,s,t,m;
int cnt[1<<N];
LL p[1<<N];
char ch[M][N+10];
double dp[1<<N];
double ans;
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	//freopen(".ans","w",sdtout);
	read(m);
	for(i=1;i<=m;i++)
	scanf("%s",ch[i]+1);
	
	n=strlen(ch[1]+1);
	
	for(i=1;i<=m;i++)
	for(j=i+1;j<=m;j++)
	{
		int mask=0;
		for(k=1;k<=n;k++)
		if(ch[i][k]==ch[j][k])
		mask|=1<<k-1;
		
		p[mask]|=1ll<<j-1,p[mask]|=1ll<<i-1;
	}
	for(i=1;i<1<<n;i++)
	cnt[i]=__builtin_popcount(i);
	
	p[(1<<n)-2]|=p[(1<<n)-1];
	for(int mask=(1<<n)-2;mask>=0;mask--)
	{
		for(i=1;i<=n;i++)
		if(((1<<i-1)&mask)==0)
		{
			p[mask]|=p[mask^(1<<i-1)];
			dp[mask]+=1.0/(n-cnt[mask])*dp[mask^(1<<i-1)];
		}
		dp[mask]+=1.0*__builtin_popcountll(p[mask])/m;
	}
	printf("%0.9lf",dp[0]);
	return 0;
}


```

### 某些代码 $\text{FST}$ 的原因

```cpp
#include <bits/stdc++.h>

#define FO(i,a,b) for (int i = (a); i < (b); i++)
#define sz(v) int(v.size())

#define BASE 139ll
#define INVBASE 604316551ll
#define MOD 1000000007ll

using namespace std;

typedef long long ll;

char s[55][55];
int u[1<<20];
double dp[1<<20];
int n,l;
ll shash[55];

ll tmp[1<<20];

void calcu() {
    FO(i,0,n) {
        FO(j,0,n) if (j != i) {
            int common = 0;
            FO(k,0,l) if (s[i][k] == s[j][k]) common |= 1<<k;
            tmp[common] |= 1ll<<i;
            //tmp[common] |= 1<<i
            //错因显然
        }
    }
    for (int j = l-1; j >= 0; j--) {
        FO(k,0,1<<l) {
            if (~k&(1<<j)) tmp[k] |= tmp[k|(1<<j)];
        }
    }
    FO(i,0,1<<l) u[i] = n-__builtin_popcountll(tmp[i]);
    //n-=__builtin_popcount(tmp[i]);
    //错误原因显然
}

int main() {
    scanf("%d", &n);
    FO(i,0,n) {
        scanf(" %s", s[i]);
    }
    l = strlen(s[0]);
    calcu();
    for (int i = (1<<l)-1; i >= 0; i--) {
        if (u[i] == n) dp[i] = 0.;
        else {
            FO(j,0,l) if (~i&(1<<j)) {
                int ni = i|(1<<j);
                dp[i] += ((u[ni]-u[i]) + (n-u[ni]) * (1+dp[ni]));
            }
            dp[i] /= l-__builtin_popcount(i);
            dp[i] /= n-u[i];
        }
    }
    printf("%.14lf\n", dp[0]);
}
//注释掉的是原先的错误代码 
//wa 10 
//By JoeyWheeler
```

```cpp
#include <iostream>

using namespace std;

const int MAXM = 20;
const int MAXN = 60;

long double dp[1 << MAXM];
int cnt[1 << MAXM];
bool marked[1 << MAXM];
string s[MAXN];
long long coef[MAXM + 10][MAXM + 10];
int main()
{
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> s[i];
	int m = s[0].length();
	int mMask = 1 << m;
	long double ans = 0;
	for (int j = mMask - 2; j >= 0; j--)
		cnt[j] = __builtin_popcount(j);
	coef[0][0] = 1;
	for (int i = 1; i <= m; i++)
	{
		coef[i][0] = coef[i][i] = 1;
		for (int j = 1; j < i; j++)
			coef[i][j] = coef[i - 1][j] + coef[i - 1][j - 1];
	}
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < mMask - 1; j++)
			marked[j] = false;
		for (int j = 0; j < n; j++)
		{
			if (i == j)
				continue;
			int tmp = 0;
			for (int k = 0; k < m; k++)
				if (s[i][k] == s[j][k])
					tmp |= 1 << k;
			marked[tmp] = true;
		}
		//marked[0]=true;
        //不应该有这一句，不然 n=1  会出问题
        for (int t = 0; t < m; t++)
			for (int j = 0; j < mMask; j++)
				marked[j] |= marked[j | (1 << t)];
		ans += m;
		for (int i = 0; i < mMask - 1; i++)
			if (!marked[i])
				ans -= 1.0 / coef[m][cnt[i]];
		//cerr << dp[0] << endl;
	}
	ans /= n;
	cout.precision(12);
	cout << fixed << ans << endl;

}
//By matrix
//wa 22
```

