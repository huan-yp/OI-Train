## CF1706 小总结

其实都会做，但是各种各样的原因导致了没在场上 AK

### ABC

A 题没考虑清楚就在写，WA 了一发样例，然后慢悠悠调好交上去过。

B 题愣了一会儿，弄了个伪 DP 上去，稍微有点磨蹭，但还好。

C 题做得无可挑剔。

### D

D 题先想到可以枚举一个端点，二分另一个，$O(n)$ check，但是发现枚举一个端点之后，可以快速计算另一个端点的最优值，得到一个 $O(n^2)$ 的枚举 max 的做法过了 D1，然后感觉其实只需要查 $max\_val/k-max\_val/k+\sqrt N$ 和 $max\_val/k-max\_val/1$，写好交上去过了 Pretests，但是 FST 了，后面想到其实对 min 分类限制更多。暴力算 $min\in [1,B]$，然后对于 $min\in(B,k]$，可以发现 $k\in [1,\lceil\frac{10^5}{B}\rceil]$，考虑维护 max 的变化，可以用一个 vector 记一下 $a_i/k$ 的所有可能，共 $n\times \lceil\frac{10^5}{B}\rceil$ 种，可以 $O(1)$ 维护该变量，搞定。

其实也可以枚举 max，同样考虑 min 的值，考虑每一个 $a_i$ 的最优值，不太可行，于是考虑每一个 $k$ 可以让哪些值取到最优，发现会取 $k$ 的一定是 $a_i\ge(max+1)*(k-1)$ 的，而我们要考虑的是 min，所以取其中最小的计算就行，发现对 $k$ 总的枚举量是 $O(n\log n)$ 级别的。

启发我们在这种整除最优问题考虑除数对被除数的影响范围。

### E

E 题在考场上想到了可以类似整体二分的做，先给所有的二分，然后再合并一次，查询每一个询问是否可行。查询的维护可以 Dsu on Tree 带一个维护线段的 Set，复杂度 $O(n\log^3n)$，感觉能信仰，就写了，可惜没交上去。赛后发现其实有些边界的小错，但是交了还是 TLE 了。告诉我们 Set 操作搞个 $10^7$ 问题还是比较大。

后面发现可以将询问直接塞进 Dsu 的过程中，但是处理询问只能处理较小的那一边，如果是小的合到大的上面去，此时询问挂在大的上面，会非常的恼火。于是就把询问拆到两个上面去，又发现可能两个询问会在合并时变成一个但是还没解决，所以合并的时候如果变成一个就又找了一个还没合并的把询问扔上去。

然后又 TLE 了，赛后仔细分析复杂度，发现不对劲，比如有个 $O(n)$ 的点，然后又有个略小于它但主要是询问的点，然后合并的时候把询问全部扔到另一个点上去了，然后另一个点同这个 $O(n)$ 点合并的时候又把询问全部扔了，询问就扔了 $O(n^2)$ 次，寄。

然后想到可以把线段合并的过程记下来，这个就是严格 $O(n\log n)$ 级别了，后面做一个二维偏序回答询问。成功 AC。

其实 E 题和最近做的题都暴露出几个问题，思维模式僵化，没有办法 Think out of box，同时代码中常常犯一些不容易注意到的小错误，依赖数据调试。

### Sum up

关于代码小错的问题，我觉得一边写一边静态查是一个比较理想的解决方案，**先认真核实思路的正确性，再检查代码和思路是否一致**，同时可以在关键点插入数据输出。

思维上的问题，估计还只有多做题。

### 收获 1：Dsu on tree 的复杂度理解

Dsu on tree，复杂度证明的过程是这样的：考虑一个点的权值 $w_i$，当合并时，复杂度贡献为 $O(\min(w_u,w_v)$，将 $w_i$ 视为 $w_i$ 个元素。考虑每个元素的贡献次数，发现每个元素仅在其所在集合大小翻倍时贡献。所以复杂度正确。

**因此，权值的构成不影响其时间复杂度**

如果在合并的时候进行了额外的对 $w_i$ 的修改，比如我的错误做法，时间复杂度就应该认真分析了。

### 收获 2: Kruscal 重构树的应用和连通性

E 题可以用 Kruscal 重构树做，具体的，先做最小生成树，顺便合并点，现在一个连通块就是一个点，合并两个连通块时，新建一个点，点权为这条边的权值，作为被合并的两个点的父亲，任意两个点联通的时最小权值就是它们的 lca，然后区间 lca 应该都会。事实上甚至没有必要做区间 LCA，我们考虑 $i,i+1$ 什么时候联通，设其时间为 $f(i)$，可以发现 $ans(a,b)=\max\limits_{i\in[a,b)} f(i)$，证明比较容易，首先必须取到这个值，否则必然有两个点不连通，其次，如果取到这个值，那么一定都联通，over ，复杂度 $O(n\log n)$

已经知道这个性质了，那么，将询问放到 $dsu$ 合并过程中的方法也不难写了，合并时处理其中一个询问即可。

### 收获3:LCA 的一些性质

从 2 中的性质，我们总结出了一些 LCA 的共有性质。

#### Theorem1.1

不妨叫它 LCA 的排列包含性质。

对于一棵树的一个点集 $S$ ，以及 $S$ 的任意一个排列 $P$ ，$S$ 的 LCA，必定在集合 $\{lca(p_i,p_{i+1}),i\in[0,|S|)\}$ 中。

即 $lca(S)\in \{lca(p_i,p_{i+1}),i\in[0,|S|)\}$

#### Lemma1.2

对三个点 $u,v,w$ ，$lca(u,v,w)\in\{lca(u,v),lca(u,w)\}$，即 Theorem1.1 对 $|S|=3$ 成立。

如果 $lca(u,v,w)\neq lca(u,v)$，那么 $w$ 不在 $lca(u,v)$ 子树内。

所以 $lca(u,v,w)=lca(lca(u,v),w)=lca(v,w)=lca(u,w)$

#### Lemma1.3(lca 结合律)

$lca(S)=lca(lca(S-\{u\}),u)$

若 $lca(S)=lca(lca(S-\{u\}))$，则结论显然成立，否则，$u$ 位于 $lca(S-\{u\})$ 子树外。结论同样成立。

#### Proof1.1

对 $S$ 集合大小归纳，设其大小为  $n$，当前排列为 $P$，且对于 $k<n$，Theorem1.1 成立。

对于一个点 $u=P_n$，记 $S'=S-\{u\}$，由 Lemma1.3 有 $lca(S)=lca(S',u)$，若 $lca(S)=lca(S')$ ，结论显然成立，否则，有 $u$ 在 $lca(S')$ 子树外，得到 $\forall v\in S',lca(S)=lca(S',u)=lca(u,v)$，得 $lca(S)=lca(P_n,P_{n-1})$

#### Lemma2.1

对三个元素 $u,v,w$ ，满足 $dfn[u]<dfn[v]<dfn[w]$，有 $lca(w,u,v)=lca(u,w)$。

由 Lemma1.2，$lca(u,v,w)\in\{lca(u,v),lca(u,w)\}$。

假设 $lca(u,v,w)=lca(u,v)$ 并且 $lca(u,v)\neq lca(u,w)$。

有 $w$ 在 $lca(u,w)$ 子数内，为 $lca(u,v)$ 的后代，又有 $dfn[v]>dfn[u]$，因为 $u,w$ 在 $lca(u,v,w)$ 同一儿子的子树内，因此有 $dfn[v]>dfn[w]$，矛盾，故假设不成立。

故有 $lca(u,v,w)=lca(u,w)$

#### Theorem2.2(lca 的 dfs 有序性质1)

对满足 dfs 序递增的树上点序列 $a$，有 $lca(a_1,a_n)=lca(a)$

归纳证明，设对 $k=n-1$ 成立。

由 Lemma1.3， $lca(a)=lca(a_{n},a-\{a_n\})=lca(lca(a_1,a_{n-1}),a_{n})$

由 Lemma2.1，Lemma1.3，$lca(lca(a_1,a_{n-1}),a_{n})=lca(a_1,a_{n-1},a_n)=lca(a_1,a_n)$

#### Theorem2.3(lca 的 dfs 有序性质2)

对满足 dfs 序递增的树上点序列 $a$，有 $lca(a_1,a_n)\in \{lca(a_i,a_{i+1}),i\in[1,n)\}$

由 Theorem2.1 ，$lca(a_1,a_n)=lca(a)$

由 Theorem1.1，$lca(a) \in \{lca(a_i,a_{i+1}),i\in[1,n)\}$





